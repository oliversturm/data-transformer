{"version":3,"sources":["../data-transformer.js"],"names":[],"mappings":"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","file":"data-transformer.js","sourcesContent":["/**\n * A module of data transformation helpers.\n * @module data-transformer\n */\n\n/**\n * map is a generator function that accepts an iterable **source** parameter and an **iterator** function. It iterates the source and applies the iterator to each element, yielding the results.\n * map implements the standard map function known from many functional environments, differing from standard JavaScript language implementations as well as those in lodash or underscore by accepting and returning iterators.\n * @param {function(element, index)} iterator - The iterator function to apply to each element of **source**. For compatibility with other implementations, an index is passed as a second parameter. The **iterator** is expected to return the result of mapping the given element.\n * @param {iterable} source - The source iterable that will be iterated\n * @return {iterable} The iterable sequence of mapped values\n */\nexport function* map(iterator, source) {\n    let index = 0;\n\n    for (let v of source) {\n\tyield iterator(v, index++);\t\n    }\n}\n\n// Hm... if Babel ever gets working tail call optimization, this might be nice.\n// function foldRecursive(reducer, initialValue, source) {\n//     const iterator = source[Symbol.iterator]();\n//     function fold_(r, v, xs, i) {\n// \tconst x = xs.next();\n// \treturn x.done ?\n// \t    v : fold_(r, r(v, x.value, i), xs, i + 1);\n//     }\n//     return fold_(reducer, initialValue, iterator, 0);    \n// }\n\n/**\n * fold accepts an iterable **source** parameter, a **reducer** function and an **initialValue** for the reduction. It iterates the source and applies the **reducer** sequentially to the values of the sequence, passing in the result from the previous reduction to each new **reducer** call. This function is similar to the standard **reduce** function on JavaScript arrays, and to reduce and fold implementations in various libraries. It is supplied here to eliminate dependencies for data-transformer.js, and to supply an implementation that works with iterables as input.\n* @param {function(result, value, index)} reducer - The reducer function that is called for each value from the source sequence. The result parameter receives **initialValue** on first call, afterwards the result from the previous reduction. An index is also passed for compatibility with other implementations. The **reducer** is expected to return the result of the value reduction step.\n* @param {value} initialValue - The value used for **result** in the first call to **reducer**\n* @param {iterable} source - The source iterable that will be iterated\n* @return {value} The result returned by the final call to **reducer**\n*/\nexport function fold(reducer, initialValue, source) { \n    let r = initialValue;\n    let i = 0;\n    \n    for (let x of source){\n\tr = reducer(r, x, i++);\n    }\n\n    return r;\n}\n\n/**\n * iterableOfIterablesToObjects is a generator function that accepts a **source** parameter, which is expected to be an iterable containing other iterables. The outer iterable is iterated and each of the sub-iterables is converted into an object. The field names for this object can be passed in the parameter **fieldNames** and are applied sequentially to the data found in the sub-iterables. If fewer fieldNames are given then there are values in a given sub-iterable, field names for further values are generated automatically, by default using the **fieldPrefix** and a sequential number for the field position. **fieldPrefix** can also be a function, in which case it is invoked as a callback expected to return a field name.\n * @param {iterable} source - The source iterable that will be iterated\n * @param {array} fieldNames - Field names for elements of the sub-iterables. Default value: `[]`\n * @param {string | function} fieldPrefix - Defines the field name prefix used for generated field names, if there are fewer field names given in **fieldNames** than there are elements in a given sub-iterable. If the type of this parameter is `string`, it overrides the default field prefix of \"field\". \n\nIf **fieldPrefix** is a function, it is called with four parameters when a field name needs to be generated: **(1)** the sub-iterable, **(2)** the index of the current sub-iterable in the top-level iterable, **(3)** the current element of the sub-iterable for which a field name is to be generated and **(4)** the index of the current element of the sub-iterable. \n\nA **fieldPrefix** function is expected to return either a `string` (the prefix) or an object of this structure: `{ prefix: string, skipNumbering: bool }`. If `skipNumbering` is true, no field position indicator is appended to the `prefix`.\n * @return {iterable} The iterable sequence of generated objects\n */\nexport function* iterableOfIterablesToObjects(source, fieldNames = [], fieldPrefix = \"field\") {\n    const defaultName = (a, ai, v, vi) => {\n\tlet prefix = fieldPrefix;\n\tlet skipNumbering = false;\n\tif (typeof fieldPrefix === \"function\") {\n\t    let r = fieldPrefix(a, ai, v, vi);\n\t    if (typeof r === \"object\") {\n\t\tprefix = r.prefix;\n\t\tif (r.skipNumbering) {\n\t\t    skipNumbering = r.skipNumbering;\n\t\t}\n\t    }\n\t    else {\n\t\tprefix = r;\n\t    }\n\t}\n\treturn prefix + (skipNumbering ? \"\" : vi);\n    };\n    \n    yield* map((a, ai) => {\n\treturn fold((r, v, vi) => {\n\t    r[vi < fieldNames.length ? fieldNames[vi] : defaultName(a, ai, v, vi)] = v;\n\t    return r;\n\t}, {}, a);\n    }, source);\n}\n\n/** \n * flattenOneToN is a generator function that accepts a **source** parameter, which is expected to be an iterable yielding objects that include other iterables in their fields. These fields are called n-fields and a list of such n-fields can be passed in the **nFields** parameter. If no n-field names are passed, n-fields will be auto-detected. **flattenOneToN** returns a sequence of objects composed of all fields from the **source** objects, plus the fields from objects referred to by iterable n-fields.\n * @param {iterable} source - The source iterable, the \"one\" part of a 1-to-N data structure\n * @param {array} nFields - fields of the **source** objects that should be projected to the result set. Default values is `[]`. N-fields are auto-detected if none are provided for this parameter.\n * @param {object}  - Defines how n-field detection works. Default value is `{ perSourceObject: false, dynamicDetector: undefined }`, and n-field auto-detection is performed by analyzing the first object yielded by the **source** sequence. **dynamicDetector** can be set to a function that handles n-field detection instead of the built-in algorithm, and if **perSourceObject** is true, detection will be performed for each object instead of once for the sequence (this works both with the built-in detection algorithm and with a custom one).\n * @return {iterable} An iterable sequence of result objects. These objects contain all fields found in the **source** sequence objects with the exception of those declared as n-fields. In addition, the objects contain all fields from the sub-iterable objects of the n-fields. If there is more than one n-field, the sequence contains objects reflecting all permutations of the n-field sub-iterable combinations.\n */\nexport function* flattenOneToN(source, nFields = [], nFieldHandling = {\n    perSourceObject: false,\n    dynamicDetector: undefined\n}) {\n    function* findNfields(o) {\n\tfor (let field in o) {\n\t    if (typeof o[field] != \"string\" && typeof o[field][Symbol.iterator] === \"function\"){\n\t\tyield field;\n\t    }\n\t}\n    }\n\n    let _nFields = nFields;\n    \n    if (nFields.length == 0 && !nFieldHandling.perSourceObject) {\n\tconst { value: firstValue, done } = source[Symbol.iterator]().next();\n\tif (!done) {\n\t    _nFields = Array.from(nFieldHandling.dynamicDetector ?\n\t\t\t\t  nFieldHandling.dynamicDetector(firstValue) : findNfields(firstValue));\n\t}\t\n    }\n    \n    function copyFields(source, target, exclusions=[], sourceName=\"\") {\n\tif (source != null && typeof source === \"object\") {\n\t    for (let f in source) {\n\t\tif (! exclusions.includes(f)) {\n\t\t    target[f] = source[f];\n\t\t}\n\t    }\n\t}\n\telse {\n\t    if (!sourceName) {\n\t\tthrow `copyFields encountered a non-object source (${source}), but no sourceName was provided.`;\n\t    }\n\t    target[sourceName] = source;\n\t}\n\treturn target;\n    }\n\n    function cloneObject(source) {\n\treturn copyFields(source, {});\n    }\n    \n    for (let d of source) {\n\tif (nFields.length == 0 && nFieldHandling.perSourceObject) {\n\t     _nFields = Array.from(nFieldHandling.dynamicDetector ?\n\t\t\t\t  nFieldHandling.dynamicDetector(d) : findNfields(d));\n\t}\n\t\n\tlet o = copyFields(d, {}, _nFields);\n\t\n\tfunction* recurse(fieldIndex, o) {\n\t    if (_nFields.length - fieldIndex < 1) {\n\t\treturn;\n\t    }\n\t    \n\t    const myList = d[_nFields[fieldIndex]];\n\t    if (myList && myList.length > 0) {\n\t\tconst originalO = cloneObject(o);\n\t\t\n\t\tfor (let value of d[_nFields[fieldIndex]]) {\n\t\t    let iterationO = cloneObject(originalO);\n\t\t    copyFields(value, iterationO, [], _nFields[fieldIndex]);\n\t\t    \n\t\t    yield* recurse(fieldIndex + 1, iterationO);\n\t\t    if (fieldIndex === _nFields.length - 1){\n\t\t\tyield iterationO;\n\t\t    }\n\t\t}\n\t    }\n\t    else {\n\t\tyield* recurse(fieldIndex + 1, o);\n\t\tif (fieldIndex === _nFields.length - 1){\n\t\t    yield o;\n\t\t}\n\t    }\n\t}\n\n\tif (_nFields.length > 0){\n\t    yield* recurse(0, o);\n\t}\n\telse {\n\t    yield o;\n\t}\n    }\n}\n"]}